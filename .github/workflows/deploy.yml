name: Deploy to Local VM
#
on:
  # Trigger after successful build workflow
  workflow_run:
    workflows: ["Build & Test (Reusable)"]  # Replace with your main workflow name
    types:
      - completed
    branches: [main, master]
  
  # Allow manual deployment for testing
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy even if build failed'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: docker.io  # Using Docker Hub
  IMAGE_NAME: my-app  # Replace with your app name

jobs:
  # Check if we should deploy
  check-build-status:
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
    steps:
      - name: Check build workflow status
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Manual deployment triggered"
          elif [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Build workflow succeeded, proceeding with deployment"
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "Build workflow failed, skipping deployment"
          fi

  # Build and push Docker image
  build-docker-image:
    needs: check-build-status
    if: needs.check-build-status.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Deploy to VirtualBox VM
  deploy-to-vm:
    needs: [check-build-status, build-docker-image]
    if: needs.check-build-status.outputs.should-deploy == 'true'
    runs-on: ubuntu-latest
    
    steps:
      - name: Deploy to VirtualBox VM
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.VM_HOST }}          # localhost (for NAT) or VM IP (for bridged)
          username: ${{ secrets.VM_USERNAME }}  # Your VM username
          key: ${{ secrets.VM_SSH_KEY }}        # Your private SSH key
          port: ${{ secrets.VM_SSH_PORT }}      # 2222 (for NAT) or 22 (for bridged)
          script: |
            echo "Starting deployment to VM..."
            
            # Update Docker images
            echo "Pulling latest Docker image..."
            docker pull ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
            
            # Stop and remove existing container
            echo "Stopping existing container..."
            docker stop ${{ env.IMAGE_NAME }} 2>/dev/null || echo "No container to stop"
            docker rm ${{ env.IMAGE_NAME }} 2>/dev/null || echo "No container to remove"
            
            # Start new container
            echo "â–¶Starting new container..."
            docker run -d \
              --name ${{ env.IMAGE_NAME }} \
              --restart unless-stopped \
              -p 80:3000 \
              -e NODE_ENV=production \
              ${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest
            
            # Wait a moment for container to start
            sleep 5
            
            # Verify container is running
            if docker ps | grep -q ${{ env.IMAGE_NAME }}; then
              echo "Container is running successfully!"
              docker ps | grep ${{ env.IMAGE_NAME }}
            else
              echo "Container failed to start!"
              docker logs ${{ env.IMAGE_NAME }} || echo "No logs available"
              exit 1
            fi
            
            # Clean up old images (keep last 3 versions)
            echo "Cleaning up old Docker images..."
            docker image prune -f
            
            echo "Deployment completed successfully!"

      - name: Test deployment
        run: |
          echo "Testing deployment..."
          sleep 10  # Give the app time to fully start
          
          # Test different connection types
          if [[ "${{ secrets.VM_SSH_PORT }}" == "2222" ]]; then
            # NAT setup - test via localhost:8080
            TEST_URL="http://localhost:8080"
            echo "Testing NAT setup at $TEST_URL"
          else
            # Bridged setup - test via VM IP
            TEST_URL="http://${{ secrets.VM_HOST }}"
            echo "Testing bridged setup at $TEST_URL"
          fi
          
          # Simple health check (adjust URL as needed)
          for i in {1..5}; do
            echo "Health check attempt $i/5..."
            if curl -f -s $TEST_URL >/dev/null 2>&1; then
              echo "App is responding at $TEST_URL"
              exit 0
            else
              echo "App not ready yet, waiting..."
              sleep 10
            fi
          done
          
          echo "Health check failed, but deployment may still be successful"
          echo "Try accessing your app manually at $TEST_URL"

  # Notify about deployment status
  notify-result:
    needs: [build-docker-image, deploy-to-vm]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Deployment Summary
        run: |
          echo "Deployment Summary"
          echo "===================="
          
          if [[ "${{ needs.deploy-to-vm.result }}" == "success" ]]; then
            echo "Deployment: SUCCESS"
            echo "Your app should be available at:"
            if [[ "${{ secrets.VM_SSH_PORT }}" == "2222" ]]; then
              echo "   http://localhost:8080 (NAT setup)"
            else
              echo "   http://${{ secrets.VM_HOST }} (Bridged setup)"
            fi
          else
            echo "Deployment: FAILED"
            echo "Check the logs above for error details"
          fi
          
          echo ""
          echo "Useful commands for your VM:"
          echo "docker ps                    # See running containers"
          echo "docker logs ${{ env.IMAGE_NAME }}       # Check app logs"
          echo "docker restart ${{ env.IMAGE_NAME }}    # Restart the app"