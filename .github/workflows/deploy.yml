name: Deploy to VirtualBox VM

on:
  # Trigger on push to main branches
  push:
    branches: [ main, master ]
  
  # Trigger after successful build workflow
  workflow_run:
    workflows: ["Build & Test (Reusable)"]  # Replace with your actual workflow name
    types: [completed]
    branches: [main, master]
  
  # Allow manual deployment for testing
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy even if build failed'
        required: false
        default: false
        type: boolean

env:
  APP_NAME: your-app-name
  CONTAINER_NAME: your-app-container

jobs:
  deploy:
    name: Deploy to VM
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      
    - name: Setup SSH
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H ${{ secrets.HOST_IP }} >> ~/.ssh/known_hosts
        
    - name: Deploy Application
      run: |
        ssh deploy@${{ secrets.HOST_IP }} << 'EOF'
          set -e
          
          echo "üöÄ Starting deployment..."
          
          # Create app directory if it doesn't exist
          mkdir -p /home/deploy/apps/${{ env.APP_NAME }}
          cd /home/deploy/apps/${{ env.APP_NAME }}
          
          # Clone or pull latest code
          if [ ! -d ".git" ]; then
            echo "üì• Cloning repository..."
            git clone ${{ github.server_url }}/${{ github.repository }} .
          else
            echo "üì• Pulling latest changes..."
            git fetch origin
            git reset --hard origin/${{ github.ref_name }}
          fi
          
          # Build Docker image
          echo "üî® Building Docker image..."
          docker build -t ${{ env.APP_NAME }}:latest .
          
          # Stop and remove existing container
          echo "üõë Stopping existing container..."
          docker stop ${{ env.CONTAINER_NAME }} 2>/dev/null || true
          docker rm ${{ env.CONTAINER_NAME }} 2>/dev/null || true
          
          # Run new container
          echo "‚ñ∂Ô∏è Starting new container..."
          docker run -d \
            --name ${{ env.CONTAINER_NAME }} \
            --restart unless-stopped \
            -p 80:3000 \
            -e VERSION="${{ github.sha }}" \
            ${{ env.APP_NAME }}:latest
          
          # Wait for container to be healthy
          echo "‚è≥ Waiting for application to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:80 > /dev/null 2>&1; then
              echo "‚úÖ Application is healthy!"
              break
            fi
            echo "‚è≥ Waiting... ($i/30)"
            sleep 2
          done
          
          # Cleanup old images
          echo "üßπ Cleaning up old images..."
          docker image prune -f
          
          echo "üéâ Deployment completed successfully!"
        EOF
        
    - name: Verify Deployment
      run: |
        echo "üîç Verifying deployment..."
        ssh deploy@${{ secrets.HOST_IP }} << 'EOF'
          if curl -f http://localhost:80 > /dev/null 2>&1; then
            echo "‚úÖ Application is responding correctly!"
            docker ps | grep ${{ env.CONTAINER_NAME }}
          else
            echo "‚ùå Application health check failed!"
            docker logs ${{ env.CONTAINER_NAME }} --tail 20
            exit 1
          fi
        EOF